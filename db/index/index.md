# 인덱스

## 인덱스의 개념
> 인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것   
데이터의 저장 (insert, update, delete) 성능을 희생하고 읽기 속도를 높이는 기능

## 인덱스의 장단점
### 장점 
* 이미 정렬이 되어 있어 검색 속도가 매우 빨라질 수 있다. (항상 그렇지는 않다)
* 해당 쿼리의 부하가 줄어들어 시스템 전체 성능이 향상된다.

### 단점
* 데이터베이스 공간을 차지해서 추가적인 공간이 필요해진다. 
    - 대략 10% 정도를 차지한다.
* 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
    - 책의 목차 페이지를 처음부터 만드려면 오래 걸리는 것과 유사하다고 볼 수 있다.
* 데이터의 변경작업(insert, update, delete)이 많을 경우 성능이 안좋아 질 수 있다.
    - 페이지가 꽉차 이동할 공간이 없을 경우 페이지 분할이 발생하여 성능에 큰 영향을 미친다 (특히 insert)

## 인덱스의 종류
### 클러스터형 인덱스
> 사전 처럼 책의 내용 자체가 순서대로 정렬되어 있어 인덱스 자체가 책의 내용과 같은 것 (데이터 자체가 인덱스 역할을 하는 것)
* 테이블 당 하나만 존재하는 인덱스
* PK를 지정하면 해당 컬럼으로 클러스터 인덱스가 자동 생성된다.
* PK가 없는 경우 UK 에 NOT NULL 을 걸어주면 클러스터 인덱스가 된다.
* 인덱스 생성시 데이터 페이지 전체가 다시 정렬된다.
    - 이미 대용량의 데이터가 입력된 상태에서 인덱스를 생성하면 DB에 심각한 부하를 줄 수 있다.
* 인덱스 자체의 리프 페이지가 곧 데이터이다.
    - 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다.
* 보조 인덱스 보다 검색 속도는 더 빠르다. 
    - 보조 인덱스 보다 찾아야 할 페이지 수가 더 적다
    - 보조 인덱스 보다 데이터 입력/수정/삭제는 더 느리다.

### 보조 인덱스
> 책과 같이 목차가 별도로 있고 목차를 찾은 후에 표시된 페이지에 내용이 있는 것
* MySQL 이 아닌 다른 DBMS 에서는 비클러스터형 인덱스 라고 한다.
* UK를 지정하면 해당 컬럼으로 보조 인덱스가 자동으로 생성된다.
* 인덱스 생성시 데이터 페이지는 그대로 있고 별도의 페이지에 인덱스를 구성한다.
* 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터의 주소값이다.
    - 클러스터 인덱스보다 찾아야 할 페이지 수가 더 많다.
    - 클러스터 인덱스보다 검색 속도는 느리지만, 데이터 입력/수정/삭제는 더 빠르다.
* 여러개 생성할 수 있다.

### 클러스터 인덱스와 보조 인덱스가 혼합되어 있는 경우
> 현실의 테이블은 PK 와 UK가 같이 있는 경우가 많다
* 클러스터 인덱스는 그대로 변함이 없지만 보조 인덱스의 경우 데이터 페이지의 주소값이 아닌 클러스터 인덱스의 키 값을 가지게 된다.
    - 보조 인덱스를 먼저 검색한 후 다시 클러스터 인덱스의 루트 페이지부터 검색한다.
    - 이 구조로 인해 검색 속도는 손해를 보지만 데이터 추가, 수정, 삭제에서는 부하가 적다
    


### 테이블의 인덱스 확인하는 방법
* SHOW INDEX FROM 테이블명
* PRIMARY KEY 는 key_name 컬럼 값이 PRIMARY 가 되고 그 외 다른 키는 별도 지정하지 않으면 컬럼명이 된다.

## 인덱스의 내부 작동
### B-TREE (Balanced Tree, 균형트리)
> 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재 정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리.    
항상 양쪽 자식의 밸런스를 유지하므로, 무조건 O(logN)의 시간 복잡도를 가지게 된다.

