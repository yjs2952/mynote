# 트랜잭션
> 작업의 완전성을 보장해주는 기능.   
논리적인 작업 셋을 모두 완벽하게 처리하거나(commit) 혹은 처리하지 못했을 경우 원 상태로 복구해서(rollback) 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

## MyISAM 과 InnoDB의 차이점
### MyISAM
* 트랜잭션 기능이 없다.
    - 논리적인 작업 셋이 중간에 실패한 경우 작업의 일부만 적용된다
    - rollback 되지 않는다.
* MySQL 5.5 이전 버전의 기본 스토리지 엔진
* Table 단위의 Lock 을 지원한다.
    - select 연산에 최적화 되어있다.
    - 블로그 처럼 한 사람이 글을 쓰고 많은 사람이 읽는 방식에서 좋은 성능을 낸다.

### InnoDB
* 트랜잭션 기능을 지원한다.
* 더 높은 참조 무결성 제한
    - 데이터 무결성 보장
* 더 높은 동시성 보장
* FK 외래키 지원
* FK 와 Row 단위의 Lock 지원

## InnoDB의 잠금 방식

### InnoDB의 잠금 종류
### 레코드 락 (Record lock, Record only lock)
* 레코드 자체를 잠그는 락
* InnoDB 스토리지 엔진의 경우 레코드 자체가 아니라 인덱스의 레코드를 잠그는 방식을 사용한다.
* 인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 한다.

### 갭 락 (Gap lock)
* 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 방식
    - 레코드와 레코드 사이 간격에 새로운 레코드가 생성되는 것을 제어하는 것

### 넥스트 키 락 (Next key lock)
* 레코드 락과 갭 락을 합쳐 놓은 형태의 락
* 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에 만들어 낸 결과와 동일한 결과를 만들도록 보장하는 역할

### 비관적 잠금
* 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다.
* 현재 트랜잭션에서 변경하려 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다라는 비관적인 상황을 가정한 잠금방식
* 높은 동시성 처리에 유리하다.

### 낙관적 잠금
* 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할 것이라고 낙관적으로 가정한 잠금 방식
* 우선 순위 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있다면 rollback 처리

### 인덱스와 잠금
* 레코드 자체를 잠금하는 것이 아닌 인덱스를 잠그는 방식
    - update 쿼리를 통해 1개의 레코드를 인덱스(보조 인덱스)에 조건을 걸어 변경을 했다면 실제로 인덱스가 걸린 레코드는 여럿일 수 있다.
    - InnoDB는 인덱스에 락이 걸리기 때문에 실제로 변경된 데이터는 1개 일지라도 **인덱스에 조건으로 걸리는 레코드가 수백개라면 이 수백개의 레코드가 모두 락이 걸린다**.
    - 만약 테이블에 인덱스가 하나도 없는 경우 테이블을 풀 스캔하여 update 작업을 하는데 이 과정에서 모든 레코드가 락이 걸린다. 

        ``` mysql
        -- first_name 에 보조 인덱스가 걸린 경우
        -- employees 테이블에 first_name = 'Goergi' 인 레코드는 250건이 있으며
        -- first_name = 'Goergi' AND last_name = 'Klassen' 인 사원은 1명만 존재한다.
        -- 인덱스에 걸린 250건의 레코드가 락이 걸린다.
        -- 인덱스가 없다면 모든 레코드가 락이 걸린다.

        UPDATE FROM employees SET hire_date = now()
        WHERE first_name = 'Goergi' AND last_name = 'Klassen';
        ```

### 트랜잭션 격리 수준과 잠금
