# 스프링 AOP

## AOP 란
> 관점 지향 프로그래밍 (Aspect-Oriented Programming) 으로 횡단 관심사를 구현하는 툴

### 횡단 관심사 (crosscutting concerns)
- 애플리케이션에서 코드가 중복되고 강력하게 결합돼 다른 로직과 분리할 수 없는 애플리케이션 로직
- AOP를 이용하면 관심사(concerns)라는 개별 로직을 모듈화하고 코드를 복제하거나 의존성을 만들지 않고도 관심사를 여러 영역에 적용가능
- 예) 로깅, 보안 등

## AOP 용어

#### 1. 조인포인트(Joinpoint)
- 애플리케이션 실행 과정 내의 명확한 지점. AOP를 사용하여 **추가 로직을 삽입할 수 있는 특정 지점**
- 메서드의 명시적 호출(call)
- 메서드 참조에 의한 호출(invoke)
- 클래스 초기화, 객체 인스턴스 생성 등

#### 2. 어드바이스(Advice)
- 특정 조인포인트에 실행되는 코드로 애플리케이션 클래스 내 메서드
- ```@After```(조인포인트 이전), ```@Before```(조인 포인트 이후) 등

#### 3. 포인트컷(Pointcut)
- 언제 어드바이스를 실행할지를 정의할 때 사용하는 조인포인트의 모음
- 포인트컷을 생성하면 애플리케이션의 컴포넌트에 어드바이스를 적용하는 방법을 상세히 제어할 수 있음

#### 4. 애스펙트(Aspect)
- 클래스에 캡슐화된 어드바이스와 포인트컷의 조합
- 애플리케이션에 포함돼야 하는 로직과, 로직이 어디서 실행돼야 하는지를 정의

#### 5. 위빙(Weaving)
- 애플리케이션 코드의 적절한 위치에 애스펙트를 삽입하는 과정
- 컴파일 시점 AOP 솔루션에서는 일반적으로 빌드 시점 위빙을 함
- 런타임 AOP 는 런타임에 동적으로 실행
- AspectJ 는 로드 시점 위빙을 제공 (내부 JVM 클래스 로더가 바이트 코드를 로딩할 때 바이트 코드에 위빙)

#### 6. 대상(Target)
- 실행 흐름이 AOP 에 의해 수정된 객체
- 어드바이스 적용 객체 라고 부르기도 함

#### 7. 인트로덕션
- 추가 메서드나 필드를 도입해 객체의 구조를 수정하는 과정

## AOP 종류

### 정적 AOP
- 실제 바이트코드를 수정하고 애플리케이션 코드를 변경하는 방법
- 컴파일 시점 위빙 (AspectJ)
- 다른 조인포인트를 추가하더라도 애스펙트를 조금이라도 수정하게 되면 애플리케이션 전체를 다시 컴파일 해야함
- 일반적으로 동적 AOP 에 비해 성능이 좋음

### 동적 AOP
- 런타임 시점 위빙
- 스프링의 경우 어드바이스가 적용된 모든 객체 대해 프록시를 생성하여 어드바이스를 호출
- 메인 애플리케이션의 코드를 다시 컴파일 하지 않아도 애플리케이션 전체 애스팩트를 쉽게 수정할 수 있음
- 일반적으로 정적 AOP 에 비해 성능이 좋지 않음

## 스프링의 AOP 지원
- 어라운드 어드바이스
    + MethodInterceptor 인터페이스
    + 메서드가 호출되기 전과 호출된 후 반환되기 전에 기능을 수행
- 프록시
    + ProxyFactory 클래스
    + 어드바이스와 타겟을 지정하여 프록시 객체를 만들고 위빙을 한다.
- 장점
    + 어드바이스 적용 클래스가 **스프링이나 AOP 얼라이언스 인터페이스에 의존성을 갖지 않는다**
    + AOP 를 염두해 두지 않고 개발해도 거의 모든 클래스에 어드바이스 적용이 가능
- 제약점
    + ```final``` 접근 제한자를 붙인 클래스에 어드바이스 적용 불가능
        * ```오버라이드가 불가능```하기 때문에 ```프록시를 생성할 수 없음```

## 스프링 AOP 아키텍처

#### JDK 다이나믹 프록시
- 어드바이스를 적용할 객체가 인터페이스를 구현한 경우 사용되는 프록시
- 인터페이스 프록시만 지원
#### CGLIB
- 인터페이스를 구현한 객체가 아닌 경우 CGLIB 으로 프록시 생성

### 스프링 조인포인트
- 스프링 AOP는 메소드 호출 조인포인트만을 지원
- 따라서 다른 AOP 구현체에 비해 사용하기 쉬움

### 스프링 애스펙트
- 스프링 AOP의 Aspect는 Advisor 인터페이스를 구현한 클래스의 인스턴스
- 스프링은 Advisor 구현체를 제공
- PointcutAdvisor 인터페이스
    + 포인트컷을 사용해 조인포인트에 적용할 어드바이스를 제어하는 Advisor 하위 인터페이스
- IntroductionAdvisor 인터페이스
    + 인트로덕션이 적용되는 클래스를 제어하는 Advisor 하위 인터페이스

### ProxyFactory
- 스프링 AOP의 위빙과 프록시 생성 과정을 제어
- 프록시를 생성하기 전 어드바이스를 적용할 객체나 대상 객체를 지정해야함
- 내부적으로 프록시 생성 프로세스를 ```DefaultAopProxyFactory``` 의 인스턴스에 위임
    + 애플리케이션 설정에 따라 ```Cglib2AopProxy``` 또는 ```JdkDynamicAopProxy``` 에 프록시 생성을 위임

### 스프링에서 제공하는 어드바이스
1. Before
    - 메서드 실행 전에 전처리
    - 메서드에 전달된 인수, 메서드 호출 대상에 대한 완전 접근 권한을 가진다
    - 메서드 실행 자체를 제어하진 못함
    - 대상 메서드 또는 before 어드바이스가 예외를 던지면 인터셉트 체인의 이후 실행 중단, 예외가 인터셉터 체인을 통해 전달
2. After-returing
    - 조인포인트에서의 메서드 호출이 실행을 마치고 값을 반환한 후 실행
    - 메서드 호출 대상, 메서드 파라미터, 리턴 값에 접근 가능
    - 메서드가 실행 완료된 상태이므로 메소드 호출 자체를 제어하진 못함
    - 대상 메서드가 예외를 던진 경우 After-returning 어드바이스가 실행되지 않음
3. After(finally)
    - 어드바이스를 적용한 메서드의 결과와 상관없이 실행
    - 대상 메서드가 예외를 던져도 실행됨
4. Around
    - 대상 메서드 호출 전후에 실행되며 메서드 호출이 진행되는 시점을 제어할 수 있음
    - 필요시 직접 로직 구현체를 제공해 메서드를 건너뛸 수도 있음
5. Throws
    - 대상 메서드 호출이 끝난 후 호출이 예외를 던질 때에만 실행
    - 특정 예외만 잡아내는 것이 가능
    - 예외를 던진 메서드, 메서드의 인수, 호출 대상에 접근 가능

## 프록시

### JDK Dynamic Proxy
- 인터페이스를 구현한 객체만 프록시로 만들 수 있음
- JVM 이 모든 메서드 호출을 인터셉트하여 프록시의 invoke() 메서드로 라우트함
- invoke() 메서드는 호출된 메서드가 어드바이스가 적용된 메서드인지 결정
- 어드바이스 적용 대상인 경우 어드바이스 체인을 호출한 후 리플렉션을 이용하여 원본 객체의 메서드를 호출
- 특정 메서드 호출을 처리하는 방식에 대한 모든 결정이 런타임에 메서드가 호출될 때 마다 이루어짐
    + invoke() 메소드에 넘기기 전 까지 어드바이스 적용 메서드와 적용되지 않은 메서드 사이에서 결정을 하지 않음
    + 프록시의 어드바이스가 적용되던 적용되지 않던 invoke() 메서드가 호출되고 모든 검사가 이뤄짐
    + 리플렉션을 이용하여 대상이 아닌 메서드도 호출
    + 메서드가 호출될 때마다 런타임 성능에 오버헤드가 발생
    
### CGLIB Proxy
- 각 프록시에 대해 동적으로 새 클래스에 대한 바이트코드를 생성하고 이미 생성된 클래스를 사용할 수 있다면 재사용
- CGLIB 처음 프록시가 생성되면 각 메서드를 어떻게 처리할지 스프링에게 물어봄
    + JDK 프록시에서 **invoke()를 호출할 때마다 수행하는 많은 결정**이 CGLIB 에선 **한 번만 수행**
- 실제 **바이트코드를 생성**하여 유연하게 대처가능
    + 어드바이스가 적용되지 않은 메서드를 직접 호출하여 프록시로 인한 성능 오버헤드를 줄임
- 메서드가 this 를 반환할 수 있는지 판단
    + this 를 반환할 수 없는 경우 메서들 직접 호출하여 런타임 성능 오버헤드를 줄임 